"""
Unit tests for ap_common.metadata module.

Generated By: Cursor (Claude Sonnet 4.5)
"""

import pytest
from unittest.mock import patch
from ap_common.metadata import (
    get_metadata,
    enrich_metadata,
    get_filtered_metadata,
    filter_metadata,
)


class TestFilterMetadata:
    """Tests for filter_metadata function."""

    def test_basic_filtering(self):
        """Test basic metadata filtering."""
        data = {
            "file1.fits": {"type": "LIGHT", "camera": "Camera1"},
            "file2.fits": {"type": "DARK", "camera": "Camera1"},
            "file3.fits": {"type": "LIGHT", "camera": "Camera2"},
        }
        filters = {"type": "LIGHT"}

        result = filter_metadata(data, filters)

        assert len(result) == 2
        assert "file1.fits" in result
        assert "file3.fits" in result
        assert "file2.fits" not in result

    def test_multiple_filters(self):
        """Test filtering with multiple criteria."""
        data = {
            "file1.fits": {"type": "LIGHT", "camera": "Camera1", "filter": "Ha"},
            "file2.fits": {"type": "LIGHT", "camera": "Camera1", "filter": "O3"},
            "file3.fits": {"type": "LIGHT", "camera": "Camera2", "filter": "Ha"},
        }
        filters = {"type": "LIGHT", "camera": "Camera1", "filter": "Ha"}

        result = filter_metadata(data, filters)

        assert len(result) == 1
        assert "file1.fits" in result

    def test_filter_with_function(self):
        """Test filtering with a function."""
        data = {
            "file1.fits": {"exposureseconds": "60.0"},
            "file2.fits": {"exposureseconds": "120.0"},
            "file3.fits": {"exposureseconds": "300.0"},
        }
        filters = {"exposureseconds": lambda x: float(x) > 100}

        result = filter_metadata(data, filters)

        assert len(result) == 2
        assert "file2.fits" in result
        assert "file3.fits" in result
        assert "file1.fits" not in result

    def test_filter_with_int(self):
        """Test filtering with integer value."""
        data = {
            "file1.fits": {"exposureseconds": "60.0"},
            "file2.fits": {"exposureseconds": "120.0"},
        }
        filters = {"exposureseconds": 120}

        result = filter_metadata(data, filters)

        assert len(result) == 1
        assert "file2.fits" in result

    def test_filter_with_float(self):
        """Test filtering with float value."""
        data = {"file1.fits": {"temp": "25.5"}, "file2.fits": {"temp": "30.0"}}
        filters = {"temp": 25.5}

        result = filter_metadata(data, filters)

        assert len(result) == 1
        assert "file1.fits" in result

    def test_filter_missing_key(self):
        """Test that missing filter key doesn't exclude entry."""
        data = {
            "file1.fits": {"type": "LIGHT"},
            "file2.fits": {"type": "LIGHT", "camera": "Camera1"},
        }
        filters = {"camera": "Camera1"}

        result = filter_metadata(data, filters)

        # file1.fits doesn't have camera, so it's treated as OK (included)
        # file2.fits has camera matching filter, so it's included
        # Both should be included when filter key is missing
        assert len(result) == 2
        assert "file1.fits" in result
        assert "file2.fits" in result

    def test_invalid_filter_data(self):
        """Test that invalid filter data raises exception."""
        data = {"file1.fits": {"type": "LIGHT"}}

        with pytest.raises(Exception, match="Invalid filter data"):
            filter_metadata(data, None)

        with pytest.raises(Exception, match="Invalid filter data"):
            filter_metadata(data, {})

    def test_filter_with_none_value(self):
        """Test that filter with None value raises exception."""
        data = {"file1.fits": {"type": "LIGHT"}}
        filters = {"type": None}

        with pytest.raises(Exception, match="has no value"):
            filter_metadata(data, filters)


class TestGetMetadata:
    """Tests for get_metadata function."""

    @patch("ap_common.metadata.get_filenames")
    @patch("ap_common.metadata.get_file_headers")
    @patch("ap_common.metadata.enrich_metadata")
    def test_basic_metadata_loading(
        self, mock_enrich, mock_get_headers, mock_get_filenames
    ):
        """Test basic metadata loading."""
        mock_get_filenames.return_value = ["file1.fits", "file2.fits"]
        mock_get_headers.side_effect = [
            {"filename": "file1.fits", "type": "LIGHT"},
            {"filename": "file2.fits", "type": "DARK"},
        ]
        mock_enrich.return_value = {
            "file1.fits": {
                "filename": "file1.fits",
                "type": "LIGHT",
                "targetname": None,
            },
            "file2.fits": {
                "filename": "file2.fits",
                "type": "DARK",
                "targetname": None,
            },
        }

        result = get_metadata(["dir1"], profileFromPath=False)

        assert len(result) == 2
        assert "file1.fits" in result
        assert "file2.fits" in result

    @patch("ap_common.metadata.get_filenames")
    @patch("ap_common.metadata.get_file_headers")
    @patch("ap_common.metadata.enrich_metadata")
    def test_with_required_properties(
        self, mock_enrich, mock_get_headers, mock_get_filenames
    ):
        """Test loading with required properties."""
        mock_get_filenames.return_value = ["file1.fits"]
        mock_get_headers.return_value = {"filename": "file1.fits", "type": "LIGHT"}
        mock_enrich.return_value = {
            "file1.fits": {
                "filename": "file1.fits",
                "type": "LIGHT",
                "targetname": None,
                "camera": None,
            }
        }

        result = get_metadata(
            ["dir1"], profileFromPath=False, required_properties=["camera"]
        )

        assert "camera" in result["file1.fits"]

    @patch("ap_common.metadata.get_filenames")
    @patch("ap_common.metadata.get_file_headers")
    @patch("ap_common.metadata.enrich_metadata")
    def test_targetname_always_required(
        self, mock_enrich, mock_get_headers, mock_get_filenames
    ):
        """Test that targetname is always added to required properties."""
        mock_get_filenames.return_value = ["file1.fits"]
        mock_get_headers.return_value = {"filename": "file1.fits"}
        mock_enrich.return_value = {
            "file1.fits": {"filename": "file1.fits", "targetname": None}
        }

        result = get_metadata(["dir1"], profileFromPath=False)

        assert "targetname" in result["file1.fits"]


class TestEnrichMetadata:
    """Tests for enrich_metadata function."""

    @patch("ap_common.metadata.get_fits_headers")
    def test_enrich_fits_file(self, mock_get_fits):
        """Test enriching metadata for FITS file."""
        mock_get_fits.return_value = {
            "type": "LIGHT",
            "camera": "Camera1",
            "targetname": "M42",
        }

        data = {"file1.fits": {"filename": "file1.fits", "type": None}}

        result = enrich_metadata(
            data, profileFromPath=False, required_properties=["type"]
        )

        assert result["file1.fits"]["type"] == "LIGHT"
        assert result["file1.fits"]["camera"] == "Camera1"
        assert result["file1.fits"]["targetname"] == "M42"

    @patch("ap_common.metadata.get_xisf_headers")
    def test_enrich_xisf_file(self, mock_get_xisf):
        """Test enriching metadata for XISF file."""
        mock_get_xisf.return_value = {"type": "LIGHT", "camera": "Camera1"}

        data = {"file1.xisf": {"filename": "file1.xisf", "type": None}}

        result = enrich_metadata(
            data, profileFromPath=False, required_properties=["type"]
        )

        assert result["file1.xisf"]["type"] == "LIGHT"

    def test_enrich_cr2_file(self):
        """Test enriching metadata for CR2 file."""
        data = {"file1.cr2": {"filename": "file1.cr2"}}

        # CR2 files only get enriched if required_properties are specified
        # Location is not available from CR2 file headers, so it must be provided
        result = enrich_metadata(
            data,
            profileFromPath=False,
            required_properties=["latitude"],
            latitude="40.7128",
            longitude="-74.0060",
        )

        # CR2 files get latitude/longitude from provided parameters
        assert result["file1.cr2"]["latitude"] == "40.7128"
        assert result["file1.cr2"]["longitude"] == "-74.0060"

    def test_enrich_cr2_file_missing_location_error(self):
        """Test that enriching CR2 file without location raises error when required."""
        data = {"file1.cr2": {"filename": "file1.cr2"}}

        # CR2 files require location to be provided if it's in required_properties
        with pytest.raises(ValueError, match="Required property 'latitude' is missing"):
            enrich_metadata(
                data,
                profileFromPath=False,
                required_properties=["latitude"],
                # latitude and longitude not provided
            )

    def test_no_enrichment_needed(self):
        """Test that files with all properties don't need enrichment."""
        data = {
            "file1.fits": {
                "filename": "file1.fits",
                "type": "LIGHT",
                "camera": "Camera1",
                "targetname": "M42",
            }
        }

        result = enrich_metadata(
            data,
            profileFromPath=False,
            required_properties=["type", "camera", "targetname"],
        )

        # Should not call get_fits_headers if all properties present
        assert result["file1.fits"]["type"] == "LIGHT"

    def test_filename_always_set(self):
        """Test that filename is always set in result."""
        data = {"file1.fits": {"filename": "file1.fits", "type": "LIGHT"}}

        result = enrich_metadata(data, profileFromPath=False)

        assert result["file1.fits"]["filename"] == "file1.fits"


class TestGetFilteredMetadata:
    """Tests for get_filtered_metadata function."""

    @patch("ap_common.metadata.get_metadata")
    @patch("ap_common.metadata.filter_metadata")
    def test_basic_filtered_metadata(self, mock_filter, mock_get):
        """Test getting filtered metadata."""
        mock_get.return_value = {
            "file1.fits": {"type": "LIGHT", "camera": "Camera1"},
            "file2.fits": {"type": "DARK", "camera": "Camera1"},
        }
        mock_filter.return_value = {
            "file1.fits": {"type": "LIGHT", "camera": "Camera1"}
        }

        result = get_filtered_metadata(
            ["dir1"], filters={"type": "LIGHT"}, profileFromPath=False
        )

        assert len(result) == 1
        assert "file1.fits" in result
        mock_get.assert_called_once()
        mock_filter.assert_called_once()

    @patch("ap_common.metadata.get_metadata")
    @patch("ap_common.metadata.filter_metadata")
    def test_filter_keys_added_to_required(self, mock_filter, mock_get):
        """Test that filter keys are added to required properties."""
        mock_get.return_value = {"file1.fits": {"type": "LIGHT"}}
        mock_filter.return_value = {"file1.fits": {"type": "LIGHT"}}

        get_filtered_metadata(
            ["dir1"],
            filters={"type": "LIGHT", "camera": "Camera1"},
            profileFromPath=False,
        )

        # Check that get_metadata was called with filter keys in required_properties
        call_args = mock_get.call_args
        assert "type" in call_args.kwargs["required_properties"]
        assert "camera" in call_args.kwargs["required_properties"]
