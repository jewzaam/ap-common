"""
Header normalization functions and data dictionaries.

Generated By: Cursor (Claude Sonnet 4.5)
"""

import os
import re
from datetime import datetime, timedelta

# Date/datetime format constants
# These can be overridden by projects that need different formats
INPUT_FORMAT_DATETIME = r"%Y-%m-%dT%H:%M:%S"
OUTPUT_FORMAT_DATE = r"%Y-%m-%d"
OUTPUT_FORMAT_DATETIME = r"%Y-%m-%d_%H-%M-%S"


def normalize_filterName(name: str):
    """
    Normalizes filter names to standard short forms for known filters.
    """
    output = name
    if name == "BaaderUVIRCut":
        output = "UVIR"
    elif name == "OptolongLeXtreme":
        output = "LeXtr"
    elif name == "S2":
        output = "S"
    elif name == "Ha":
        output = "H"
    elif name == "O3":
        output = "O"
    elif name == "":
        output = "RGB"
    return output


def normalize_date(date: str, input_format: str = None, output_format: str = None):
    """
    Converts a date string to the standard output date format, adjusting for timezone offset.

    Args:
        date: Date string to normalize
        input_format: Optional input format override (defaults to INPUT_FORMAT_DATETIME)
        output_format: Optional output format override (defaults to OUTPUT_FORMAT_DATE)
    """
    input_fmt = input_format or INPUT_FORMAT_DATETIME
    output_fmt = output_format or OUTPUT_FORMAT_DATE

    # TODO fix the timezone offset, it's hardcoded to account for UTC.  but it depends on where the data was acquired
    # Handle different date string formats
    date_str = date

    # Remove timezone info if present (everything after the last 'Z' or '+'/'-')
    if "Z" in date_str or "+" in date_str or date_str.count("-") > 2:
        # Keep only the date and time part
        date_str = date_str.split("Z")[0].split("+")[0].split("-", 3)[0:3]
        if isinstance(date_str, list):
            date_str = "-".join(date_str[:3])

    # Handle fractional seconds by truncating to whole seconds
    if "." in date_str:
        date_str = date_str.split(".")[0]

    # Try to parse as datetime first, then as date-only if that fails
    try:
        parsed_date = datetime.strptime(date_str, input_fmt)
        adjusted_date = parsed_date - timedelta(hours=16)
    except ValueError:
        # If datetime parsing fails, try date-only format
        try:
            parsed_date = datetime.strptime(date_str, output_fmt)
            # For date-only, don't apply timezone offset since there's no time component
            adjusted_date = parsed_date
        except ValueError:
            # If both fail, return the original string
            return date_str

    return datetime.strftime(adjusted_date, output_fmt)


def normalize_datetime(date: str, input_format: str = None, output_format: str = None):
    """
    Converts a date string to the standard output datetime format.

    Args:
        date: Date string to normalize
        input_format: Optional input format override (defaults to INPUT_FORMAT_DATETIME)
        output_format: Optional output format override (defaults to OUTPUT_FORMAT_DATETIME)
    """
    input_fmt = input_format or INPUT_FORMAT_DATETIME
    output_fmt = output_format or OUTPUT_FORMAT_DATETIME

    # Handle different date string formats
    date_str = date

    # Remove timezone info if present (everything after the last 'Z' or '+'/'-')
    if "Z" in date_str or "+" in date_str or date_str.count("-") > 2:
        # Keep only the date and time part
        date_str = date_str.split("Z")[0].split("+")[0].split("-", 3)[0:3]
        if isinstance(date_str, list):
            date_str = "-".join(date_str[:3])

    # Handle fractional seconds by truncating to whole seconds
    if "." in date_str:
        date_str = date_str.split(".")[0]

    # Try to parse as datetime first, then as date-only if that fails
    try:
        parsed_date = datetime.strptime(date_str, input_fmt)
    except ValueError:
        # If datetime parsing fails, try date-only format
        try:
            parsed_date = datetime.strptime(date_str, OUTPUT_FORMAT_DATE)
            # For date-only, set time to midnight
            parsed_date = parsed_date.replace(hour=0, minute=0, second=0)
        except ValueError:
            # If both fail, return the original string
            return date_str

    return datetime.strftime(parsed_date, output_fmt)


def normalize_target_name(input: str):
    """
    Splits a target name into the main target and panel if present, removing single quotes.
    Returns a list [target, panel].
    """
    target = input
    panel = ""
    m = re.match("(.*) Panel (.*)", target)
    if m is not None and m.groups() is not None and len(m.groups()) == 2:
        target = m.groups()[0]
        panel = m.groups()[1]
    else:
        panel = ""
    # strip single quote
    target = target.replace("'", "")
    return [target, panel]


def normalize_headers(input: dict):
    """
    Normalizes a dictionary of headers using FILTER_NORMALIZATION_DATA and CONSTANT_NORMALIZATION_DATA.
    Converts keys to lower case if not found in normalization data.
    Handles special cases for target name and constants.
    """
    output = {}
    for key in input.keys():
        value = input[key]
        if value is not None and key in FILTER_NORMALIZATION_DATA.keys():
            for normalized_keyword in FILTER_NORMALIZATION_DATA[key]:
                conversion_function = FILTER_NORMALIZATION_DATA[key][normalized_keyword]
                output[normalized_keyword] = conversion_function(value)
        else:
            # simply convert to lower case
            output[key.lower()] = value
    # final special case, strip panel out of target name
    if "panel" not in output and "targetname" in output and output["targetname"]:
        x = normalize_target_name(output["targetname"])
        output["targetname"] = x[0]
        output["panel"] = x[1]
    # handle constants
    for key in CONSTANT_NORMALIZATION_DATA.keys():
        for value in CONSTANT_NORMALIZATION_DATA[key].keys():
            if key in output and output[key] == value:
                for ckey in CONSTANT_NORMALIZATION_DATA[key][value].keys():
                    cvalue = CONSTANT_NORMALIZATION_DATA[key][value][ckey]
                    if ckey not in output:
                        output[ckey] = cvalue
    return output


def denormalize_header(header: str):
    """
    Converts a normalized header name back to its original FITS header form if possible.
    """
    for dheader in FILTER_NORMALIZATION_DATA.keys():
        nheader = list(FILTER_NORMALIZATION_DATA[dheader].keys())[0]
        if header == nheader:
            return dheader

    # didn't find it..
    return None


def normalize_filename(
    output_directory: str, input_filename: str, headers: dict, statedir: str = None
):
    """
    Constructs a normalized filename based on output directory, input filename, headers, and state directory.
    Ensures required headers are present and builds a path with relevant metadata.
    """
    file_extension = os.path.splitext(input_filename)[1]

    # the absolute bare minimum required headers
    required_headers = [
        "type",
        "optic",
        "camera",
        "date",
        "exposureseconds",
        "datetime",
        "filter",
    ]

    # check that all required headers are available.
    for rh in required_headers:
        if rh not in headers:
            raise Exception(
                f"missing required header '{rh}' for file: {input_filename}"
            )

    # collect output as an array.  will join it at the end
    output = [output_directory]
    type = headers["type"]

    if type == "BIAS" or type == "DARK" or type == "FLAT":
        # technically we care about focal ratio for flats
        # BUT this is used to repair raw data which does not include focal ratio
        # so we leave focal ratio out for flats.
        output.append(f"{headers['optic']}+{headers['camera']}")
    elif type == "LIGHT":
        output.append(
            f"{headers['optic']}@f{headers['focal_ratio']}+{headers['camera']}"
        )

    if type == "LIGHT":
        if statedir is not None and len(statedir) > 0:
            output.append(statedir)
        try:
            # if there is no targetname this may be a snapshot.  ignore it and move on.
            output.append(headers["targetname"])
        except KeyError as e:
            print(
                f"WARNING: missing targetname for LIGHT file, perhaps is a snapshot file: {input_filename}"
            )
            print(f"WARNING: {headers}")
            raise e

    # for all types...
    output.append(f"DATE_{headers['date']}")

    # while we don't care about filter for bias and darks, it is used generally included out of NINA
    p = f"FILTER_{headers['filter']}_EXP_{headers['exposureseconds']}"
    if "settemp" in headers:
        p = f"{p}_SETTEMP_{headers['settemp']}"
    if type == "LIGHT":
        if (
            "panel" in headers
            and headers["panel"] is not None
            and len(headers["panel"]) > 0
        ):
            p += f"_PANEL_{headers['panel']}"
    output.append(p)

    # for all types...
    p = f"{headers['datetime']}"
    for opt in ["hfr", "stars", "rmsac", "temp"]:
        if opt in headers and headers[opt] is not None and len(headers[opt]) > 0:
            p += f"_{opt.upper()}_{headers[opt]}"
    p += f"{file_extension}"
    output.append(p)

    # create the output filename
    output_filename = os.path.normpath(os.sep.join(output))

    return output_filename


# Normalization data dictionaries
# These must be defined after the normalization functions since they reference them

CONSTANT_NORMALIZATION_DATA = {
    "camera": {
        "DWARFIII": {
            "focal_ratio": "4.3",
            "type": "LIGHT",
        }
    }
}

FILTER_NORMALIZATION_DATA = {
    "DATE-OBS": {
        "date": (lambda x: normalize_date(x)),
        "datetime": (lambda x: normalize_datetime(x)),
    },
    "FILTER": {"filter": (lambda x: normalize_filterName(x))},
    "EXPOSURE": {  # preferred key for exposureseconds
        "exposureseconds": (lambda x: "{:.2f}".format(float(x)))
    },
    "EXPTIME": {"exposureseconds": (lambda x: "{:.2f}".format(float(x)))},
    "EXP": {"exposureseconds": (lambda x: "{:.2f}".format(float(x)))},
    "CCD-TEMP": {"temp": (lambda x: "{:.2f}".format(float(x)))},
    "SETTEMP": {  # preferred key for settemp
        "settemp": (lambda x: "{:.2f}".format(float(x)))
    },
    "SET-TEMP": {"settemp": (lambda x: "{:.2f}".format(float(x)))},
    "IMAGETYP": {"type": (lambda x: str(x).upper())},
    "TELESCOP": {"optic": str},
    "FOCRATIO": {"focal_ratio": str},
    "INSTRUME": {"camera": str},
    "OBJECT": {"targetname": str},
    "SITELAT": {  # preferred key for latitude
        "latitude": (lambda x: "{0:.1f}".format(float(x)))
    },
    "OBSGEO-B": {"latitude": (lambda x: "{0:.1f}".format(float(x)))},
    "SITELONG": {  # preferred key for longitude
        "longitude": (lambda x: "{0:.1f}".format(float(x)))
    },
    "OBSGEO-L": {"longitude": (lambda x: "{0:.1f}".format(float(x)))},
    "READOUTM": {"readoutmode": str},
    # M 42_15s60_Astro_20250413-193110677_27C.fits
    "astro": {"filter": (lambda x: "Astro")},
    # M 42_15s60_Duo-Band_20250413-193110677_27C.fits
    "duo-band": {"filter": (lambda x: "Duo-Band")},
}
